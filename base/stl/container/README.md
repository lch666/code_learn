#
[VS code]: 多行注释：shift + alt + a
## 容器
''' 
[array]
--静态空间，配置完之后不可改变大小

[vector]
--类似数组，随机访问效率高，连续内存空间，动态扩容（申请内存、拷贝、释放）;插入删除效率低

[list]
--环状双向链表实现，内存地址不连续；插入删除效率低；随机存取效率低O(n)；

[map]
--底层为红黑树，对key自动排序，元素不重复；插入删除O(n)

[unordered_map]
--底层为hash-table，内部元素key无序，元素不重复；查找速度快O(1)，所以占用空间；
--哈希冲突解决：

[deque]
--双端开口的线性空间，相比vector一是可以在头部进行插入和删除操作；二是没有容量(capacity)的概念，由分段连续空间组成（迭代器）
--堆中保存数据，保存形式为[堆1]->[堆2]->[堆3]->...

[queue]
--可用deque、list实现，封闭其前端入口和尾端出口，FIFO,先进先出

[stack]
--可用deque、list实现，封闭其前端开口（输入输出都在尾端操作），FILO,先进后出

[set]
--底层为红黑树，有序，元素不重复

[priority_queue]
-- 带有权值的queue，默认为最大堆结构（权值由高到低）
-- 堆排序：1. 构造大顶堆，得到最大值元素；2. 将堆顶元素与末尾元素互换，调整堆，得到第二大元素；3. 重复以上步骤



根据元素排列方式划分
【序列化容器】: array、vector、list、stack、queue、deque、priority_queue
【关联式容器】：set、map、unordered_map（key-value特定规则，没有头尾的概念）

## 树
[二叉树]
--最多两个叶子结点

[二叉搜索树]
--任何结点的键值大于其左节点下的所有键值，小于右节点下的所有键值

[平衡二叉搜索树]
--别称ALV树，Self-balancing binary search tree；左右子树高度差的绝对值不超过1，左右子树也是平衡二叉树
--插入和删除结点可能破坏平衡性，需要进行移动和旋转操作维护平衡；查找效率优于红黑树

[红黑树]
--1. 结点只有红色和黑色；2. 没有连续的红色结点；3. 每条路径上黑色结点数量一样（最长路径不超过最短路径的两倍） 4. 根结点和叶子结点（空节点）为黑色 
--最长路径不超过最短路径的两倍（相比ALV，降低插入和旋转的次数，增删结构中性能优于ALV，实现更简单，应用更为广泛），最短路径为N，最长路径在N~2N之间，增删改查的效率为logN-2logN之间

[B树]
--每个结点存多个数据，检索速度h*logn，h为树高，n为每个结点关键词树
-- 尽可能减少磁盘I/O，加快检索速度
-- 树高度减小的优势：减小磁盘读取次数，读1b数据和1kb数据时间差不多

[B+树]
-- 结点存储索引，叶子结点存数据，数据用链表串起来，便于范围查找
-- 树的高度降低，减少磁盘I/O，链表有序，便于范围查找
